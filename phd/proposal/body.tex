%%%%%%%%%% Commands --

%% General commands
\newcommand{\todo}[1]{\emph{\textcolor{red}{TODO: #1}}}
\newcommand{\note}[1]{\emph{\textcolor{blue}{NOTE: #1}}}
\newcommand{\panic}[1]{\textbf{\textcolor{red}{(#1)}}}

\renewcommand{\subsectionautorefname}{section}
\renewcommand{\subsubsectionautorefname}{section}

\newcommand{\ie}{i.e.,}
\newcommand{\eg}{e.g.,}
\newcommand{\aka}{a.k.a.}

\newcommand{\tuple}[1]{\langle #1 \rangle}
\renewcommand\qedsymbol{$\blacksquare$}

%% Hemiola

\newcommand{\hemiola}{Hemiola}

\newcommand{\listof}[1]{\ensuremath{\mathbf{#1}}}
\newcommand{\listtof}[1]{\ensuremath{\overrightarrow{#1}}}
\newcommand{\listnil}{\ensuremath{\lbrack\rbrack}}
\newcommand{\listcons}[2]{\ensuremath{#1 : #2}}
\newcommand{\listsingle}[1]{\ensuremath{\lbrack #1 \rbrack}}
\newcommand{\listapp}[2]{\ensuremath{#1 + #2}}
\newcommand{\listsub}[2]{\ensuremath{#1 - #2}}
\newcommand{\listdisj}[2]{\ensuremath{#1 \; \# \; #2}}
\newcommand{\listconcat}[1]{\ensuremath{\widehat{#1}}}
\newcommand{\sizeof}[1]{\ensuremath{|\, #1\, |}}

\newcommand{\mapupd}[3]{\listapp{#1}{(#2, #3)}}
\newcommand{\mapupds}[2]{\listapp{#1}{#2}}
\newcommand{\mapsubs}[2]{\listsub{#1}{#2}}

\newcommand{\idxOf}[1]{\ensuremath{#1.i}}

\newcommand{\propt}{\ensuremath{\mathbb{P}}}
\newcommand{\hidt}{\ensuremath{\mathbb{I}}}
\newcommand{\hvaluet}{\ensuremath{\mathbb{V}}}
\newcommand{\hmsgt}{\ensuremath{\mathbb{M}}}
\newcommand{\hostt}{\ensuremath{\mathbb{O}}}
\newcommand{\hsyst}{\ensuremath{\mathbb{S}}}
\newcommand{\hidmt}{\ensuremath{\hidt \ast \hmsgt}}
\newcommand{\hprect}{\ensuremath{\mathcal{P}}}
\newcommand{\htrst}{\ensuremath{\mathcal{T}}}

\newcommand{\hsysIn}[1]{\ensuremath{\listof{#1_{\textrm{in}}}}}
\newcommand{\hsysRq}[1]{\ensuremath{\listof{#1_{\textrm{rq}}}}}
\newcommand{\hsysRs}[1]{\ensuremath{\listof{#1_{\textrm{rs}}}}}
\newcommand{\hsys}[4]{\ensuremath{\tuple{#1, #2, #3, #4}}}
\newcommand{\hsyss}[2]{\hsys{#1}{\hsysIn{#2}}{\hsysRq{#2}}{\hsysRs{#2}}}
\newcommand{\hsysInA}[1]{\ensuremath{#1.\hsysIn{i}}}
\newcommand{\hsysRqA}[1]{\ensuremath{#1.\hsysRq{i}}}
\newcommand{\hsysRsA}[1]{\ensuremath{#1.\hsysRs{i}}}

\newcommand{\hsysobjs}[1]{\ensuremath{#1.\listof{O}}}
\newcommand{\hobjrules}[1]{\ensuremath{#1.\listof{r}}}

\newcommand{\msgIns}[1]{\listof{#1^{\textrm{ins}}}}
\newcommand{\msgOuts}[1]{\listof{#1^{\textrm{outs}}}}
\newcommand{\midxIns}[1]{\listof{\idxOf{#1^{\textrm{ins}}}}}
\newcommand{\midxOuts}[1]{\listof{\idxOf{#1^{\textrm{outs}}}}}

\newcommand{\lblEmpty}{\ensuremath{l_\epsilon}}
\newcommand{\lblIns}[1]{\ensuremath{l_{\textrm{in}}(#1)}}
\newcommand{\lblOuts}[1]{\ensuremath{l_{\textrm{out}}(#1)}}
\newcommand{\lblInt}[4]{\ensuremath{l_{\textrm{int}}(#1, #2, #3, #4)}}

\newcommand{\hmpt}{\ensuremath{\mathcal{M}}}
\newcommand{\hsttr}{\ensuremath{\listtof{\hostt} \ast \hmpt}}
\newcommand{\hstt}{\ensuremath{\mathbb{S}}}
\newcommand{\hst}[2]{\ensuremath{\tuple{#1, #2}}}
\newcommand{\hstm}[2]{\ensuremath{\left\langle\begin{array}{l}#1,\\ #2 \end{array}\right\rangle}}
\newcommand{\sysInit}[1]{\ensuremath{#1_{\textsf{init}}}}

\newcommand{\disj}[2]{\ensuremath{#1 \; \# \; #2}}
\newcommand{\nodup}[1]{\ensuremath{\textsf{nodup}\: #1}}

\newcommand{\semstep}[4]{\ensuremath{#2 \xrightarrow[#1]{#3} #4}}
\newcommand{\semsteps}[4]{\ensuremath{#2 \xRightarrow[#1]{#3} #4}}
\newcommand{\semrch}[2]{\ensuremath{#1 \Rightarrow #2}}
\newcommand{\semleg}[2]{\ensuremath{#1 \xRightarrow{#2} \bullet}}
\newcommand{\sembeh}[2]{\ensuremath{#1 \Downarrow #2}}
\newcommand{\behOf}[1]{\ensuremath{\widetilde{#1}}}

\newcommand{\refines}[2]{\ensuremath{#1 \sqsubseteq #2}}

\newcommand{\enqMsgs}[2]{\mapupds{#1}{#2}}
\newcommand{\deqMsgs}[2]{\mapsubs{#1}{#2}}

%% Serializability

\newcommand{\atomic}[3]{\ensuremath{#1 \stackrel{#2}{\rightsquigarrow} #3}}
\newcommand{\atomicLong}[3]{\ensuremath{#1 \frac{\scriptstyle{#2}}{}\hspace{-5pt}\rightsquigarrow #3}}
\newcommand{\extatomic}[4]{\ensuremath{#1 \vdash #2 \stackrel{#3}{\rightsquigarrow}_{\textsf{ext}} #4}}
\newcommand{\extatomicLong}[4]{\ensuremath{#1 \vdash #2 \frac{\scriptstyle{#3}}{}\hspace{-5pt}\rightsquigarrow_{\textsf{ext}} #4}}
\newcommand{\trsn}[2]{\ensuremath{#1 \sswarrow #2}}

\newcommand{\extatomicshort}[2]{\ensuremath{#1 \stackrel{#2}{\rightsquigarrow}_{\textsf{ext}}}}
\newcommand{\intatomicshort}[2]{\ensuremath{#1 \stackrel{#2}{\rightsquigarrow}_{\textsf{int}}}}

\newcommand{\amsgi}[1]{\ensuremath{#1^{\textrm{init}}}}
\newcommand{\amsge}[1]{\ensuremath{#1^{\textrm{end}}}}

\newcommand{\hseq}[2]{\ensuremath{#1 \parallel #2}}
\newcommand{\hsrzl}[2]{\ensuremath{\mathit{Serializable}\ #1\ #2}}
\newcommand{\hsrz}[1]{\ensuremath{\mathit{Serializable}\ #1}}

\newcommand{\strsn}[2]{\ensuremath{#1 \sswarrow_{s} #2}}
\newcommand{\hsseq}[3]{\ensuremath{#1 \parallel_{#3} #2}}

%%%%%%%%%% Contents --

\section{Introduction}\label{sec-intro}

Cache-coherence protocols have been regarded as one of the greatest correctness challenges of the hardware world.
Industry has most commonly used testing and bounded model checking for quality assurance of cache-coherence implementations, but these techniques are not sound and sometimes miss subtle bugs~\cite{ccbug}.

Research on model checking and theorem proving has produced sound techniques, though typically with significant limitations:
either the verification is of a specific protocol, or state-space-explosion concerns limit applicability to quite small cache topologies~\cite{Komuravelli:2014,Murali:2015,Banks:2017,Oswald:2018}.
In order to overcome the latter, recent approaches~\cite{Chen:2008,Chen:2010,McMillan:2016,Opeoluwa:2016,Opeoluwa:2017,Oswald:2020} utilized the notion of \emph{modularity} and successfully built verification tools that are scalable enough to verify hierarchical cache-coherence protocols.

However, these modularity disciplines impose significant restrictions in protocol design, in order to obtain clear module boundaries among caches.
A concrete limitation of modular design and verification comes when trying to verify cache-coherence protocols that are not \emph{inclusive}.
Noninclusive caches have been in common industrial use for a decade: AMD Opteron servers are known to use exclusive caches~\cite{Irazoqui:2016}, and Intel Skylake-X processors use noninclusive\footnote{Intel uses the term ``noninclusive cache'' to say that the cache is neither inclusive nor exclusive.} caches~\cite{intel-non-inclusive,Zhao:2010,Yan:2019}.

I would like to view the verification of hierarchical cache-coherence protocols from a different perspective.
Instead of decomposing a protocol design and proof, we view a cache-coherence protocol as a \emph{global} distributed protocol and look for commonalities across well-designed protocols.
It is a good start to identify ``good-hygiene'' properties, but it is even better to formalize such properties in frameworks that guide the design of protocols.
Then we can provide nonobvious and useful reasoning principles by-construction.

Looking for another way to factor proofs, we can find a hint in terminology often employed by protocol designers and verification engineers.
These protocols are distributed message-passing systems, so we can apply traditional software terminology like \emph{transaction} to them directly, and in fact we find similar intuitions employed in practice.
In order to describe a case where the protocol deals with two different requests passing through the same cache, for instance, a designer often says ``this cache acts like a \emph{serialization point} so the two transactions can safely \emph{interleave} with each other.''
While the notions of interleaving and serialization are already pervasive, I have found no past work trying to find a minimal set of conditions that ensure transactions are always serialized, formalizing them in a reusable framework.

In this proposal, I propose a framework called \hemiola{}, embedded in the Coq proof assistant, which dramatically decreases the burden of designing and formally proving hierarchical cache-coherence protocols.
In particular, on top of the framework, hardware developers can design cache-coherence protocols without worrying about possible complex interleavings among different transactions, standing for different concurrent memory accesses.
From the verification perspective, it is established that any invariant of a protocol under serialized execution is also an invariant under the interleaved executions that are necessary for good performance.

More specifically, \hemiola{} formalizes a set of message-passing distributed protocols with tree hierarchies and particular topologies of channels between nodes, with associated locks.
These protocols are defined by associating each tree node with a set of local state-transition rules that may remove messages from incoming queues and add messages to outgoing queues.
\hemiola{} exposes a domain-specific language of protocols, such that any expressible program is guaranteed to validate a \emph{serializability} property for single memory requests.
Furthermore, the framework provides a novel invariant proof method that only requires consideration of execution histories that do not interleave memory accesses -- so that almost all formal reasoning about concurrency is confined to the framework, not proofs of individual protocols.

To demonstrate usability of the framework, I plan to provide complete correctness proofs for hierarchical, noninclusive cache-coherence protocols as case studies.
I also plan to build a compilation/synthesis toolchain that converts a cache-coherence protocol described in \hemiola{} to a corresponding hardware implementation running on FPGAs.
A so-called protocol compiler would take such a role, which employes prebuilt, optimized hardware components such as caches and resource controllers.

\section{Background}

\subsection{Challenges in designing cache-coherence protocols}

Before proposing the \hemiola{} framework, we provide a simple yet motivating example to introduce cache-coherence protocols and typical challenges in the design and verification.
For simplicity, in this section, we will consider only \emph{a single memory location} and design a protocol only for this location.
We will see it is still nontrivial to design a correct protocol.

\tikzset{
  msi/.pic = {
    \node at (0, 0) {$P(S, v, S_{\tuple{1, 2}})$};
    \node at (-1.5, -1.5) {$C_1(S, v)$};
    \node at (1.5, -1.5) {$C_2(S, v)$};
    % between P and C_1
    \draw [<-<] (-0.6, -0.3) -- (-1.5, -1.2);
    \draw [<-<] (-0.4, -0.3) -- (-1.3, -1.2);
    \draw [>->] (-0.2, -0.3) -- (-1.1, -1.2);
    % between P and C_2
    \draw [<-<] (0.6, -0.3) -- (1.5, -1.2);
    \draw [<-<] (0.4, -0.3) -- (1.3, -1.2);
    \draw [>->] (0.2, -0.3) -- (1.1, -1.2);
    % C_1 external
    \draw [<-<] (-1.6, -1.8) -- (-1.6, -2.3);
    \draw [>->] (-1.4, -1.8) -- (-1.4, -2.3);
    % C_2 external
    \draw [<-<] (1.6, -1.8) -- (1.6, -2.3);
    \draw [>->] (1.4, -1.8) -- (1.4, -2.3);
  },
  msipc1/.pic = {
    \node at (0, 0) {$P(S, v, S_{\tuple{1, 2}})$};
    \node at (0, -1.5) {$C_1(S, v)$};
    % between P and C_1
    \draw [<-<] (-0.2, -0.3) -- (-0.2, -1.2);
    \draw [<-<] (0, -0.3) -- (0, -1.2);
    \draw [>->] (0.2, -0.3) -- (0.2, -1.2);
    % C_1 external
    \draw [<-<] (-0.1, -1.8) -- (-0.1, -2.3);
    \draw [>->] (0.1, -1.8) -- (0.1, -2.3);
  },
  msipc2/.pic = {
    \node at (0, 0) {$P(S, v, S_{\tuple{1, 2}})$};
    \node at (0, -1.5) {$C_2(I, \cdot)$};
    % between P and C_1
    \draw [<-<] (-0.4, -0.3) -- (-0.4, -1.2);
    \draw [<-<] (-0.2, -0.3) -- (-0.2, -1.2);
    \draw [>->] (0.4, -0.3) -- (0.4, -1.2);
    % C_1 external
    \draw [<-<] (-0.1, -1.8) -- (-0.1, -2.3);
    \draw [>->] (0.1, -1.8) -- (0.1, -2.3);
  },
  msipc3/.pic = {
    \node at (0, 0) {$P(I, \cdot, M_{\tuple{1}})$};
    \node at (0, -1.5) {$C_1(S, v)$};
    \node at (1.8, 0) {$C_2(I, \cdot)$};
    % between P and C_1
    \draw [<-<] (-0.2, -0.3) -- (-0.2, -1.2);
    \draw [<-<] (0, -0.3) -- (0, -1.2);
    \draw [>->] (0.2, -0.3) -- (0.2, -1.2);
    % between P and C_2
    \draw [<->] (0.9, 0) -- (1.2, 0);
    % C_1 external
    \draw [<-<] (-0.1, -1.8) -- (-0.1, -2.3);
    \draw [>->] (0.1, -1.8) -- (0.1, -2.3);
  },
  spec/.pic = {
    \node at (0, 0) {$\textrm{Spec}(v)$};
    % C_1 external
    \draw [<-<] (-0.4, -0.3) -- (-0.5, -0.8);
    \draw [>->] (-0.2, -0.3) -- (-0.3, -0.8);
    % C_2 external
    \draw [<-<] (0.4, -0.3) -- (0.5, -0.8);
    \draw [>->] (0.2, -0.3) -- (0.3, -0.8);
  }
}
\begin{figure}[h]
  \centering
  \begin{tikzpicture}
    \pic at (0, 0) {msi};
    \node at (2.5, -1) {$\sqsubseteq$};
    \pic at (3.7, -0.7) {spec};
  \end{tikzpicture}
  \caption{A simple MSI directory protocol}
  \vspace{-5pt}
  \label{fig-motive-1}
\end{figure}

The overall goal of cache coherence is, as the name suggests, to preserve coherence among multiple candidate values in a memory subsystem.
In other words, if the system is coherent, then it should behave like an ordinary memory.
\autoref{fig-motive-1} shows objects and channels for a simple directory-based MSI protocol.
Since we deal with only a single memory location, the specification (RHS of $\sqsubseteq$) is a single-value ($v$) container with atomic read and write.

Looking at the implementation (LHS of $\sqsubseteq$), there are three objects $P$, $C_1$, and $C_2$, and each of them has its own status (M, S, or I) and data ($v$).
A status of an object represents a permission on its local replica.
In this MSI protocol, an object can read/write the data with the M (``modified'') status, only read with S (``shared''), and cannot read/write with I (``invalid'').
The parent $P$ additionally has a data structure called a \emph{directory} to track the statuses of the children.
For example, a directory might be $S_{\tuple{1, 2}}$, meaning that both $C_1$ and $C_2$ have S status, in some logical snapshot of state.

Objects communicate through ordered channels (shown as $\rightarrowtail$ in the figure).
$C_1$ and $C_2$ have channels to receive and respond to external requests (from processor cores).
There are three types of channels between a parent and a child: a single channel for parent-to-child messages and two channels for child-to-parent requests and responses, respectively.
It is natural to wonder why two separate channels are required from a child to a parent; we will see the reason very soon.
Note that channels are depicted in a logical way; the actual hardware implementation may use different hardware components (\eg{} finite-capacity FIFOs or buses) that can simulate ordered channels.

\newcommand{\blackdiamond}{\raisebox{.4ex}{\ensuremath{\scriptscriptstyle\blacklozenge}}}
\begin{figure}[h]
  \centering
  \begin{subfigure}[b]{0.30\columnwidth}
    \centering
    \begin{tikzpicture}
      \pic at (0, 0) {msipc1};
      \node[label={[label distance=-6pt]left:{\small {\sf rqM}}}] at (-0.2, -0.7) {$\bullet$};
      \node[label={[label distance=-6pt]left:{\small {\sf rqM}}}] at (-0.1, -2.05) {$\circ$};
    \end{tikzpicture}
    \caption{$C_1$ requesting to the parent}
    \label{fig-motive-2-a}
  \end{subfigure}
  \begin{subfigure}[b]{0.36\columnwidth}
    \centering
    \begin{tikzpicture}
      \pic at (0, 0) {msi};
      \node[label={[label distance=-6pt]left:{\small {\sf rqM}}}] at (-1, -0.7) {$\circ$};
      \node[label={[label distance=-8pt]210:{\small {\sf rqI}}}] at (0.6, -0.7) {$\bullet$};
    \end{tikzpicture}
    \caption{$P$ making an invalidation request}
    \label{fig-motive-2-b}
  \end{subfigure}
  \begin{subfigure}[b]{0.30\columnwidth}
    \centering
    \begin{tikzpicture}
      \pic at (0, 0) {msipc2};
      \node[label={[label distance=-6pt]left:{\small {\sf rqM}}}] at (-0.4, -0.7) {$\blackdiamond$};
      \node[label={[label distance=-6pt]right:{\small {\sf rqI}}}] at (0.4, -0.7) {$\circ$};
      \node[label={[label distance=-6pt]right:{\small {\sf rsI}}}] at (-0.2, -0.7) {$\bullet$};
    \end{tikzpicture}
    \caption{$C_2$ responding to the parent}
    \label{fig-motive-2-c}
  \end{subfigure}
  \caption{Rule-execution cases in the simple MSI protocol}
  \vspace{-5pt}
  \label{fig-motive-2}
\end{figure}

All objects run concurrently, repeatedly executing \emph{rules} that define local state transitions.
In message-passing systems, a rule may take some messages from input channels, perform a state transition, and put messages in output channels.
A rule may also have a precondition, blocking use of that rule when the precondition does not hold.
\autoref{fig-motive-2} shows some example rule-execution cases depending on statuses of the objects.
\autoref{fig-motive-2-a} is the case where a child $C_1$ takes an external request ($\textsf{rqM}\circ$) to write data, but it does not have M status and thus forwards the request to the parent ($\textsf{rqM}\bullet$).
At this moment the child usually \emph{sets a lock} not to allow any further external requests for the value.
The following pseudocode describes the rule:
\begin{lstlisting}
Rule c1RqMToP :=
  assert !C1.locked();
  assert (C1.status != M);
  assert (C1.extRq.first == rqM);
  C1.extRq.deq();
  C1.rqToP.enq(rqM);
  C1.lock();
Endrule
\end{lstlisting}
The rule checks whether $C_1$ is not locked so it can handle $\textsf{rqM}\circ$, confirms it does not have a write permission, dequeues an external request from \slstinline{extRq}, sends a request to $P$ by using a channel \slstinline{rqToP}, and sets a lock.

As a next rule-execution step, $\textsf{rqM}\circ$ (previously outputted from \autoref{fig-motive-2-a}) is handled by the parent $P$, as shown in \autoref{fig-motive-2-b}.
It makes \emph{invalidation} requests ($\textsf{rqI}$) to the other children ($C_2$ is the only other child in this system) to change their statuses to I, since when a child has M the others should not be able to read/write the data.
After making invalidation requests, the parent also sets a lock to disallow requests from the children.

Now imagine a scenario where two children $C_1$ and $C_2$ requested $\textsf{rqM}$ to the parent (to obtain M) at the same time, and the parent decided to deal with the request from $C_1$ first.
Proper locking is indeed required here, since otherwise the parent will handle two $\textsf{rqM}$s simultaneously, which might lead to an incoherent state -- two M statuses in the system.
\autoref{fig-motive-2-c} presents this case, where an invalidation request was made to $C_2$ ($\textsf{rqI}\circ$) and even before this, $C_2$ requested $\textsf{rqM}\blackdiamond$ to the parent.
In order to handle all the requests correctly, we should carefully consider some corner cases:
\begin{itemize}
\item Since $C_2$ requested $\textsf{rqM}\blackdiamond$, it is locked when the $\textsf{rqI}\circ$ message arrives. It should still be able to handle this invalidation request even if it is locked. We see that \emph{locking should be fine-grained enough to distinguish message kinds} while handling a request.
\item Due to the existence of $\textsf{rqM}\blackdiamond$, if we had a single channel from a child to a parent, a deadlock would occur. $P$ cannot take $\textsf{rqM}\blackdiamond$ since it was locked after making an invalidation request. It cannot take $\textsf{rsI}\bullet$ as well since the response is not the first one of the ordered channel. This case shows the necessity of having multiple channels between a child and a parent.
\end{itemize}

A so-called three-channel system has been widely used and regarded as a good choice to make the design correct and live~\cite{Murali:2015,thesis:Murali:2016}.
While there are other possible correct topology and network settings, the cases shown in \autoref{fig-motive-2} at least demonstrate that it is nontrivial to construct one of them.

%% It is a typical challenge in proving correctness of a distributed protocol, asking ``if I am about to handle a certain message, is it fair to assume some properties of the global state?''

If proper topology and locking are crucial for designing a correct protocol, can we craft a domain-specific language where only conformant protocols are expressible?
That is exactly what we did with \hemiola{}, where, for instance, instead of the above pseudocode, rules are written more like the following one:
\begin{lstlisting}
Rule c1RqMToP :=
  using template RqToP;
  accepts rqM;
  assert (me.status != M);
  release rqM;
Endrule
\end{lstlisting}
Note that this pseudocode does not mention specific channels or locking at all.
Instead, it just says that the rule is for making a request to the parent (\slstinline{RqToP}), and it gives various associated assertions and actions, fitting slots associated with this kind of rule.

\hemiola{} provides \emph{rule templates} that employ proven-safe topologies and network structures and automatically set associated locks, so designers can design protocols without worrying about corner cases due to interleavings.

We further discovered that if a system is defined by using these rule templates, global invariants can be proven without explicit consideration of interference by concurrently executing memory accesses.
The key is the notion of \emph{serializability} coming originally from the database-transactions literature.

\subsection{Correctness of cache-coherence protocols}



\subsection{Formal notion of serializability}

Serializability~\cite{sz1,sz2} is a celebrated notion of concurrency correctness that originated with databases and distributed systems.
While each transaction in a system affects multiple values, serializability guarantees that concurrent execution of such transactions is correct in that the effect (state change) is the same as if the transactions were executed serially, \ie{} atomically in some order with no interleaving.

In order to understand the notion of serializability better, we first provide basic definitions of atomic histories and transactions.
A history $h$ is \emph{atomic} iff it satisfies the predicate $(\atomic{\listof{\amsgi{m}}}{h}{\listof{\amsge{m}}})$ with \emph{starting messages} $\listof{\amsgi{m}}$ and \emph{live messages} $\listof{\amsge{m}}$.

\begin{figure}[h]
  \centering
  \begin{tabular}{c}
    \begin{tikzpicture}
      \node at (0, 0) {$P$};
      \node at (-1.5, -1.5) {$C_1$};
      \node at (1.5, -1.5) {$C_2$};
      % between P and C_1
      \draw [<-<] (-0.6, -0.3) -- (-1.5, -1.2);
      \draw [<-<] (-0.4, -0.3) -- (-1.3, -1.2);
      \draw [>->] (-0.2, -0.3) -- (-1.1, -1.2);
      \node at (-0.65, -0.15) {\tiny $3$};
      \node at (-0.45, -0.15) {\tiny $4$};
      \node at (-0.25, -0.15) {\tiny $5$};
      \node[label={[label distance=-6pt]left:{\small {\sf rqM}}}] at (-1, -0.7) {$\bullet$};
      % between P and C_2
      \draw [>->] (0.6, -0.3) -- (1.5, -1.2);
      \draw [<-<] (0.4, -0.3) -- (1.3, -1.2);
      \draw [<-<] (0.2, -0.3) -- (1.1, -1.2);
      \node at (0.65, -0.15) {\tiny $8$};
      \node at (0.45, -0.15) {\tiny $7$};
      \node at (0.25, -0.15) {\tiny $6$};
      \node[label={[label distance=-6pt]left:{\small {\sf rsI}}}] at (0.6, -0.7) {$\bullet$};
      \node[label={[label distance=-6pt]right:{\small {\sf rqI}}}] at (1, -0.7) {$\bullet$};
      % C_1 external
      \draw [<-<] (-1.6, -1.8) -- (-1.6, -2.3);
      \draw [>->] (-1.4, -1.8) -- (-1.4, -2.3);
      \node at (-1.6, -2.45) {\tiny $1$};
      \node at (-1.4, -2.45) {\tiny $2$};
      \node[label={[label distance=-6pt]left:{\small {\sf rqM}}}] at (-1.6, -2.05) {$\bullet$};
      % C_2 external
      %% \draw [dotted] (1.6, -1.8) -- (1.6, -2.3);
      %% \draw [dotted] (1.4, -1.8) -- (1.4, -2.3);
      % Curves
      \draw [->] (-2.4, -2.1) to[out=90,in=-135] node[left] {\small $r_1 \in \hobjrules{C_1}$} (-1.5, -0.3);
      \draw [->] (-1.4, -0.2) to[out=45,in=135] node[above] {\small $r_2 \in \hobjrules{P}$} (1.6, -0.4);
      \draw [->] (1.7, -0.5) to[out=-45,in=-60,distance=2cm] node[below] {\small $r_3 \in \hobjrules{C_2}$} (0, -0.8);

    \end{tikzpicture}\\
    \hline
    \begin{math}
      \small
      \begin{array}{rl}
        h \triangleq & [\lblInt{\idxOf{C_1}}{\idxOf{r_1}}{\listsingle{(1, \textsf{rqM})}}{\listsingle{(3, \textsf{rqM})}};\\
        & \lblInt{\idxOf{P}}{\idxOf{r_2}}{\listsingle{(3, \textsf{rqM})}}{\listsingle{(8, \textsf{rqI})}};\\
        & \lblInt{\idxOf{C_2}}{\idxOf{r_3}}{\listsingle{(8, \textsf{rqI})}}{\listsingle{(6, \textsf{rsI})}}]\\
      \end{array}
    \end{math}
  \end{tabular}
  \caption{An example of an atomic history}
  \vspace{-5pt}
  \label{fig-ex-atomic-history}
\end{figure}

\autoref{fig-ex-atomic-history} presents an example of an atomic history.
$h$ is generated by executions of three rules, $r_1 \in \hobjrules{C_1}$, $r_2 \in \hobjrules{P}$, and $r_3 \in \hobjrules{C_2}$.
Rule $r_1$ takes an input message $\textsf{rqM}$ from the channel with index $1$, as a starting message of the history.
Rule $r_2$ takes $\textsf{rqM}$ from channel $3$, which held the output message from $r_1$.
Finally, $r_3$ takes $\textsf{rqI}$ from channel $8$, which is the output message from $r_2$.
Summing up all the rule executions, by the definition of an atomic history we get the predicate $\atomic{\listsingle{(1,\textsf{rqM})}}{h}{\listsingle{(6,\textsf{rsI})}}$.
This example shows that an atomic history intuitively captures a \emph{transaction flow} triggered by the starting messages.
Note that an atomic history does not need to be a completed transaction.
The history $h$ in the example is not completed, in the sense that the live message ($\textsf{rsI}$) is not a response to an external channel.

Now with a clear notion of atomic histories, we can easily think of sequential histories and serializability:
\begin{definition}[Sequential Histories]
  A history is sequential iff it is a concatenation of atomic histories.
  \label{def-seq}
\end{definition}
\begin{definition}[Serializability]\mbox{}\\
  \vspace{-15pt}
  \begin{enumerate}
  \item A history is serializable in the system iff there exists a sequential history that reaches the same state.
  \item A system is serializable iff every legal history is serializable in the system.
  \end{enumerate}
  \label{def-sz}
\end{definition}

We have not yet discussed how to exploit this notion of serializability.
How does it help prove trace refinement between an implementation and its spec?
There is a clear gap between two notions, serializability and trace refinement: the former only deals with \emph{reachable states}, whereas the latter only deals with \emph{behaviors}.
However, we can bridge the gap by using serializability to help prove \emph{invariants} (which only concern reachable states), since a trace-refinement proof usually requires a number of invariants of the implementation.

It is much easier to describe and prove invariants of a serializable system since 1) an invariant can be stated per-transaction, and 2) it does not need to take interleavings into account.
The following notion of \emph{atomic invariants} reflects these two benefits:
\begin{definition}[Atomic Invariants]
  $(\mathcal{A}: \listtof{\hidmt{}} \to \hsyst{} \to \hsyst{} \to \listtof{\hidmt{}} \to \propt{})$ is called an atomic invariant iff $(\mathcal{A}\ \listof{m_i}\; s_0\; s_1\; \listof{m_o})$ holds for any atomic history $h$ with $\semsteps{S}{s_0}{h}{s_1}$ and $\atomic{\listof{m_i}}{h}{\listof{m_o}}$.
  \label{def-atomic-invariant}
\end{definition}
An atomic invariant takes starting messages, a prestate, a poststate, and live messages from an atomic history.
Since it takes starting messages, we can specify which transaction we would like to deal with, via conditions on those messages.
Also, the invariant does not need to be stated considering interleavings, since the poststate is derived from the atomic history.

\section{Research Questions}

\section{Work Plan}
