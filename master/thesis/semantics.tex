\chapter{Various Semantics for Hardware Systems}

\section{Syntax}

\paragraph{Notations} TODO.

\paragraph{Expressions}
We begin by defining syntax for expressions. Expressions
consist of constant, register read, variable, and an inductive
operation among expressions.

\begin{definition}
  \label{def-expression}
  An expression $e$ is inductively defined as follows:
  \begin{center}
    \begin{math}
      \begin{array}{rcll}
        \textrm{Expression}\quad e & ::= & c & \textrm{(constant)} \\
        & | & r & \textrm{(register read)} \\
        & | & x & \textrm{(variable)} \\
        & | & \eop{e} & \textrm{(operation)} \\
      \end{array}
    \end{math}
  \end{center}
\end{definition}

Constants denotes all concrete values in hardware design. A number of
constants with different bit-widths may exist in real hardware design,
but they are abstracted into a single type. Let \setconst{} be the set
of such constants. $c \in \setconst{}$ will be used as a typical
charater representing a constant throughout the thesis.

$r \in \setregs{}$ in expression represents the value of a register
$r$, where \setregs{} is the set of register names. $x$ denotes a
variable bound by a continuation. We define syntax as a
continuation-passing style (CPS), hence the variable is used to get
the value of a continuation argument. Lastly, \eop{e} abstracts all
inductive operations among expressions. Notation $\vec{\cdot}\ $ is
used to denote the list of objects.

\paragraph{Actions}
As explained in \refsect{TODO}, an action is a unit for describing
hardware behaviors, which should ensure atomicity. Actions consist of
a write to a register, a method call, an assert, and a return.

\begin{definition}
  \label{def-action}
  An action $a$ is inductively defined as follows:
  \begin{center}
    \begin{math}
      \begin{array}{rcll}
        \textrm{Action}\quad a & ::= & \actwrite{r}{e}{a} & \textrm{(register write)} \\
        & | & \actcall{x}{f}{e}{a} & \textrm{(method call)} \\
        & | & \actlet{e}{x}{a} & \textrm{(let bind)} \\
        & | & \actifelse{e}{a}{a}{x}{a} & \textrm{(conditional branch)} \\
        & | & \actassert{e}{a} & \textrm{(assert)} \\
        & | & \actret{e} & \textrm{(return)} \\
      \end{array}
    \end{math}
  \end{center}
\end{definition}

A register write action takes a register name $r$ and an expression
$e$ to assign the evaluation of $e$ to $r$. A method call action takes
a method name $f \in \setmeths{}$ to call, an expression $e$ as an
argument. A return value for the call is bound to a variable $x$ in a
lambda continuation. \setmeths{} denotes the set of method names. An
assert action takes an expression $e$ to be checked to progress the
continuation. Lastly, A return action takes $e$ as a return
value. Note that all action components except a return action also
takes an action $a$ as a continuation.

\paragraph{Modules}
A module is a unit of hardware component which has its own state (a
set of registers), introduces internal state change fired by actions,
and creates method calls to communicate with other modules. A module
syntactically consists of registers, rules, and methods.

\begin{definition}
  \label{def-module}
  A module $m$ is inductively defined as follows:
  \begin{center}
    \begin{math}
      \begin{array}{rcll}
        \textrm{Module}\quad m & ::=
        & \modbasic{\regpair{r}{c}}{\rulepair{s}{a}}{\methodpair{f}{\lambda x.a}}
        & \textrm{(basic module)} \\
        & | & \modcomp{m}{m} & \textrm{(composed module)}
      \end{array}
    \end{math}
  \end{center}
\end{definition}

Modules is either a \emph{basic module} or a \emph{composed module}
where two modules are composed inductively. In a basic module,
registers has a form of $\listof{\regpair{r}{c}}$, where $c$ is the
default value for a corresponding register $r$. Rules are defined as
$\listof{\rulepair{s}{a}}$, where $s$ is the name of a rule and $a$ is
the body of it. Methods are defined as $\listof{\methodpair{f}{\lambda
    x.a}}$, where $f$ is the name of a method and $\lambda x.a$ is the
body of it. $x$ in the lambda form serves to take an argument of the
method.

Note that all names for registers, rules, and methods are assumed to
be globally unique in the module. A simple static checker can be
implemented to confirm there are no name conflicts inside a module.

\section{Modular Semantics}
\label{sec-semmod}

In this section, we present modular semantics for hardware design. A
version of modular semantics has been defined in \cite{murali-thesis}.
However, this section defines a slightly different version of it, in
which the current \Kami{} framework uses. The motivation is kept
unchanged: semantics are defined with respect to the module
definition, which includes the one for combining modules. The
semantics defined in this section will be used throughout the thesis,
including the consistency proofs in \refsect{TODO}. Specifically, the
semantics for expressions and actions are completely borrowed from
\cite{murali-thesis}. Other higher semantics differ.

\paragraph{Expressions}

We start defining semantics from the one for expressions.
\refdef{def-semexpr} describes denotational semantics \ssemexpr{\cdot}
for expressions.

\begin{definition}
  \label{def-semexpr}
  $\ssemexpr{\cdot} : (\sttype{}) \to \setconst$ is
  defined as follows:
  \begin{center}
    \begin{math}
      \begin{array}{rcl}
        \semexpr{c}{o} & = & c \\
        \semexpr{r}{o} & = & o(r) \\
        \semexpr{x}{o} & = & \textsf{undefined} \\
        \semexpr{\eop{e}}{o} & = & \denot{\seop{}}(\listof{\semexpr{e}{o}}) \\
      \end{array}
    \end{math}
  \end{center}
\end{definition}

The semantics for constant and register read are straightforward. The
constant itself is returned for a constant. Register read is performed
by reading its value from the \emph{old state} $o: \sttype$.

The semantics for variable is not defined, since it should be
substituted to the value by $\beta$-reduction in higher
semantics. Technically, in the \Kami{} framework, syntax is defined by
PHOAS~\cite{adam-icfp}, thus the variable term is abstracted into a
syntax constructor $\textsf{Var}$. In this case, we rather can define
$\semexpr{\textsf{Var}\ v}{o} = v$, where $v$ is already substituted
to a value but still contained in the constructor.

Lastly, the semantics for operation is defined by using the semantic
definition for \seop{}, denoted as $\denot{\seop{}}$. Arguments are
inductively evaluated by the same semantics function.

\paragraph{Actions}

Action is the basic unit where the communication among modules are
triggered by method calls. As defined in \refdef{def-action}, actions
contain a method call. A method call can be either internal (calling a
method in the module), or external (calling a method not in the
module).

In the modular semantics, all method calls are treated
nondeterministically. In other words, the semantics for method calls,
on the level of action, are defined as if we know the return value of
the method for every argument. The validity of such assumptions are
checked on higher-level semantics.

The semantics for actions have a form of a judgment relation
\semact{o}{a}{u}{cs}{v}, where $o : \sttype{}$ is the old state, $a$
is the target action, $u : \sttype{}$ is the \emph{updated state}
after executing $a$, $cs : \lbtype{}$ is the map from method names to
pairs of argument and return values. Lastly, $v$ is the return value
of $a$.

\begin{definition}
  \label{def-semaction}
  The judgment \semact{o}{a}{u}{cs}{v} is defined as follows:
  \begin{center}
    \begin{math}
      \begin{array}{c}
        \inference[ActionWriteReg:]{\semact{o}{a}{u}{cs}{v} & \semexpr{e}{o} = v_r}
                  {\semact{o}{\actwrite{r}{e}{a}}{\stupd{u}{r}{v_r}}{cs}{v}} \\
        \mbox{} \\
        \inference[ActionCall:]{\semact{o}{(\lambda x.a)\ v_r}{u}{cs}{v} & \semexpr{e}{o} = v_a}
                  {\semact{o}{\actcall{x}{f}{e}{a}}{u}{\lblupd{cs}{f}{(v_a, v_r)}}{v}} \\
        \mbox{} \\
        \inference[ActionLet:]{\semact{o}{(\lambda x.a)\ v_l}{u}{cs}{v} & \semexpr{e}{o} = v_l}
                  {\semact{o}{\actlet{e}{x}{a}}{u}{cs}{v}} \\
        \mbox{} \\
        \inference[ActionIfElseT:]{\semact{o}{a_t}{u_t}{cs_t}{v_t} &
          \semact{o}{(\lambda x.a)\ v_t}{u}{cs}{v} &
          \semexpr{e}{o} = \btrue{}}
                  {\semact{o}{\actifelse{e}{a_t}{a_f}{x}{a}}{\splus{u_t}{u}}{\splus{cs_t}{cs}}{v}} \\
        \mbox{} \\
        \inference[ActionIfElseF:]{\semact{o}{a_f}{u_f}{cs_f}{v_f} &
          \semact{o}{(\lambda x.a)\ v_f}{u}{cs}{v} &
          \semexpr{e}{o} = \bfalse{}}
                  {\semact{o}{\actifelse{e}{a_t}{a_f}{x}{a}}{\splus{u_f}{u}}{\splus{cs_f}{cs}}{v}} \\
        \mbox{} \\
        \inference[ActionAssert:]{\semact{o}{a}{u}{cs}{v} & \semexpr{e}{o} = \btrue{}}
                  {\semact{o}{\actassert{e}{a}}{u}{cs}{v}} \\
        \mbox{} \\
        \inference[ActionReturn:]{\semexpr{e}{o} = v}
                  {\semact{o}{\actret{e}}{\emptymap{}}{\emptymap{}}{v}} \\
        \mbox{} \\
      \end{array}
    \end{math}
  \end{center}
\end{definition}

Semantics for actions do not check double-writes of registers or
double-calls of method calls. For instance, in the rule
ActionWriteReg, an evaluated value is simply updated to the updated
state $u$ by the register name $r$, without confirming $u$ does not
have the value for $r$. Similarly, ActionCall does not check $cs$
already has the value for $f$. The reason is that these conditions can
be checked \emph{statically}; we call such conditions
\emph{well-formedness} of actions. Detailed static checks and
properties will be discussed in \refsect{sec-wf}.

An assert and a return action have straightforward semantics. Assert
requires its argument $e$ to be \btrue{}, in order to continue
execution. Return simply evaluates the expression $e$ to return the
value.

\paragraph{Substep}
Once the semantics for actions are defined, it should be applied to
describe the semantics of rule or method executions. As explained in
\refsect{TODO}, \Bluespec{} and \Kami{} follow the one-rule-at-a-time
semantics; only one rule is executed in a cycle, while multiple method
calls are executed. The \Substep{} semantics defines a single
execution by a rule or a method. It is simply a lift from the
semantics for actions, since a rule or a method is defined by an
action.

A label is firstly employed on this semantics, representing
communications with other external modules. A label has a form of
\semlbl{\alpha}{ds}{cs}. $\alpha$ contains the information whether the
label is formed by a rule or not. If the label is formed by a rule $s
\in \setrules$, it takes \alpharule{s}. Otherwise, it takes
\alphameth{}. $\alpha$ is used to ensure that the label follows the
one-rule-at-a-time semantics. $ds$ denotes \emph{defined methods},
indicating multiple methods executed in a cycle. Similarly, $cs$
denotes \emph{called methods}, indicating methods which are called in
a cycle.

The \Substep{} semantics have a form of a judgment relation
\semsstep{m}{o}{u}{\alpha}{ds}{cs}, where $m$ is the target module,
$o$ is the old state, $u$ is the updated state, and
\semlbl{\alpha}{ds}{cs} is the label formed by the execution.

\begin{definition}
  \label{def-semsstep}
  The judgment \semsstep{m}{o}{u}{\alpha}{ds}{cs} is defined as follows:
  \begin{center}
    \begin{math}
      \begin{array}{c}
        \inference[EmptyRule:]{}
                  {\semsstep{m}{o}{\emptymap}
                    {\alpharule{\epsilon}}{\emptymap}{\emptymap}} \\
        \mbox{} \\
        \inference[EmptyMeth:]{}
                  {\semsstep{m}{o}{\emptymap}
                    {\alphameth}{\emptymap}{\emptymap}} \\
        \mbox{} \\
        \inference[SingleRule:]{\rulepair{s}{a} \in \rulesofm{m} & \semact{o}{a}{u}{cs}{v}}
                  {\semsstep{m}{o}{u}{\alpharule{s}}{\emptymap}{cs}} \\
        \mbox{} \\
        \inference[SingleMeth:]{\methodpair{f}{\lambda x.a} \in \methsofm{m} &
          \semact{o}{(\lambda x.a)\ v_a}{u}{cs}{v_r}}
                  {\semsstep{m}{o}{u}{\alphameth{}}{\lblupd{}{f}{(v_a, v_r)}}{cs}} \\
        \mbox{} \\
      \end{array}
    \end{math}
  \end{center}
\end{definition}

EmptyRule and EmptyMeth describe cases where no progress is made in a
cycle. These cases are similar to $\epsilon$-steps for describing
program behaviors, like the one in CompCert~\cite{TODO}. However, an
empty step by a rule and one by a method should be separately defined
in the \Substep{} semantics, in order to give explicit information
when defining the refinement relation. See \refsect{TODO} for details.

SingleRule and SingleMeth describe the case where a rule or a method
is executed in a cycle, respectively. In SingleRule, a rule $(s, a)$
should be defined in the module $m$. \rulesofm{m} is a function which
collects all rules in the module, inductively defined as follow:
\begin{definition}
  \label{def-rulesofm}
  \mbox{}
  \begin{center}
    \begin{math}
      \begin{array}{lcl}
        \rulesofm{(\_, \listof{\rulepair{s}{a}}, \_)} & = & \listof{\rulepair{s}{a}}\\
        \rulesofm{(\modcomp{m1}{m2})} & = & (\rulesofm{m1}) \cup (\rulesofm{m2})\\
      \end{array}
    \end{math}
  \end{center}
\end{definition}
Similarly, a method $(f, \lambda x.a)$ should be defined in $m$ in the
SingleMeth case. \methsofm{m} is also similarly defined as follow:
\begin{definition}
  \label{def-methsof}
  \mbox{}
  \begin{center}
    \begin{math}
      \begin{array}{lcl}
        \methsofm{(\_, \_, \listof{\methodpair{f}{\lambda x.a}})} & = & \listof{\methodpair{f}{\lambda x.a}} \\
        \methsofm{(\modcomp{m1}{m2})} & = & (\methsofm{m1}) \cup (\methsofm{m2})\\
      \end{array}
    \end{math}
  \end{center}
\end{definition}
Once a rule or a method is found, proper labels are formed simply by
using information from the semantics of actions.

\paragraph{Substeps}
The \Substeps{} semantics collect multiple substeps which are
simultaneously executed in a cycle. There are a few conditions whether
substeps can be merged or not. Basically the updated states and labels
from \Substep{} are used. Firstly, two substeps with \alpharule{\cdot}
labels cannot be merge, since it breaks the one-rule-at-a-time
semantics. Two updated states should be disjoint unless it breaks the
double-write policy. Similarly, two defined methods and two called
methods should be disjoint not to break double-call.

The \Substeps{} semantics have a form of a judgment relation
\semsss{m}{o}{u}{l}, arguments mostly have the same meaning as in
\Substep{}. $l$ denotes the label formed in a cycle.

\begin{definition}
  \label{def-semsss}
  The judgment \semsss{m}{o}{u}{l} is defined as follows:
  \begin{center}
    \begin{math}
      \begin{array}{c}
        \inference[SubstepsNil:]{}
                  {\semsss{m}{o}{\emptymap}
                    {\semlbl{\alphameth}{\emptymap}{\emptymap}}} \\
        \mbox{} \\
        \inference[SubstepsCons:]{\semsss{m}{o}{u_1}{l_1} & \semsstepr{m}{o}{u_2}{l_2} & \sdisj{u_1}{u_2} & \ldisj{l_1}{l_2}}
                  {\semsss{m}{o}{\splus{u_1}{u_2}}{\lplus{l_1}{l_2}}} \\
        \mbox{} \\
      \end{array}
    \end{math}
  \end{center}
\end{definition}

In SubstepsCons, disjointnesses of states and labels are both denoted
by the operation \sdisj{}{}, while definitions differ. For states
$u_1$ and $u_2$, \sdisj{u_1}{u_2} defines the two finite state maps
are disjoint, which can be defined naturally:

\begin{center}
  \begin{math}
    \sdisj{u_1}{u_2} \triangleq \forall r. r \notin \domof{u_1} \vee r \notin \domof{u_2}
  \end{math}
\end{center}

For labels $l_1$ and $l_2$, \ldisj{l_1}{l_2} defines the two labels
are combinable:

\begin{definition}
  \label{def-ldisj}
  \mbox{}
  \begin{center}
    \begin{math}
      \begin{array}{rcl}
        \ldisj{l_1}{l_2} & \triangleq &
        \anndisj{(\annotof{l_1})}{(\annotof{l_2})} \wedge
        \mdisj{(\defsof{l_1})}{(\defsof{l_2})} \wedge
        \mdisj{(\callsof{l_1})}{(\callsof{l_2})} \textrm{, where} \\
        \anndisj{\alpha_1}{\alpha_2} & \triangleq &
        (\alpha_1 = \alphameth) \vee (\alpha_2 = \alphameth) \\
      \end{array}
    \end{math}
  \end{center}
\end{definition}

Once the disjointnesses are defined, we can use the disjoint union for
updated states \splus{u_1}{u_2} and the merged label \lplus{l_1}{l_2},
where the label merging is defined as follows:

\begin{definition}
  \label{def-lplus}
  \mbox{}
  \begin{center}
    \begin{math}
      \begin{array}{rcl}
        \lplus{l_1}{l_2} & \triangleq &
        \semlbl{\annplus{\annotof{l_1}}{\annotof{l_2}}}
               {\mplus{\defsof{l_1}}{\defsof{l_2}}}
               {\mplus{\callsof{l_1}}{\callsof{l_2}}} \textrm{, where} \\
        \annplus{\alpha_1}{\alpha_2} & \triangleq &
        \textsf{if}\ \alpha_1 = \alpharule{s}\ \textsf{then}\ \alpha_1\
        \textsf{else}\ \alpha_2 \\
      \end{array}
    \end{math}
  \end{center}
\end{definition}

The only nontrivial definition is \annplus{\alpha_1}{\alpha_2}, which
is to take the rule annotation from two annotations, \alphameth{} if
both of them are not a rule annotation. Note that the two annotations
cannot both be the rule annotation by the condition
\anndisj{\alpha_1}{\alpha_2}.

\paragraph{Step}
The \Step{} semantics describe behaviors of a module where all
internal communications are hidden. It employes the \Substep{}
semantics, and hides all internal calls of the label from the
substeps. Hiding internal calls includes to check whether the calls
are correctly defined, \ie{}, if a label of substeps contains a called
method $f$ with an argument and a return value $(v_a, v_r)$, then the
label also should contain a defined method with the same name and the
value.

The \Step{} semantics have a form of a judgment relation
(\semstep{m}{o}{u}{l}), arguments have the same meaning as in
\Substeps{}.

\begin{definition}
  \label{def-semstep}
  The judgment \semstep{m}{o}{u}{l} is defined as follows:
  \begin{center}
    \begin{math}
      \begin{array}{c}
        \inference[StepIntro:]{\semsss{m}{o}{u}{l} & \wellhidden{m}{(\hide{l})}}
                  {\semstep{m}{o}{u}{l}} \\
        \mbox{} \\
      \end{array}
    \end{math}
  \end{center}
\end{definition}

(\hide{l}) computes the label where all internal (corresponding) calls
are removed, defined as follow:

\begin{definition}
  \label{def-hide}
  \mbox{}
  \begin{center}
    \begin{math}
      \hide{\semlbl{\alpha}{ds}{cs}} = \semlbl{\alpha}{ds - cs}{cs - ds},
    \end{math}
  \end{center}
\end{definition}
where a finite map subtraction operation $(-)$ is naturally defined; it
removes all pairs $(k, v)$ on the left-hand side map if the right-hand
side map contains $(k, v)$.

(\wellhidden{m}{l}) ensures $l$ does not contain internal calls with
respect to $m$, defined as follow:

\begin{definition}
  \label{def-wellhidden}
  \mbox{}
  \begin{center}
    \begin{math}
      \wellhidden{m}{\semlbl{\alpha}{ds}{cs}} \triangleq (\keysdisj{ds}{\callsofm{m}}) \wedge (\keysdisj{cs}{\methsofm{m}}),
    \end{math}
  \end{center}
\end{definition}
where a \callsofm{m} operator statically collects all method names
which are called in $m$.

\begin{definition}
  \label{def-callsof}
  \mbox{}
  \begin{center}
    \begin{math}
      \begin{array}{lcl}
        \callsofm{(\_, \rulepair{s}{a_r}, \methodpair{f}{\lambda x.a_m})}
        & = & \listof{\callsofa{a_r}} \cup \listof{\callsofa{a_m}} \\
        \callsofm{(\modcomp{m_1}{m_2})} & = & \callsofm{m_1} \cup \callsofm{m_2} \\
        \callsofa{(\actwrite{r}{e}{a})} & = & \callsofa{a} \\
        \callsofa{(\actcall{x}{f}{e}{a})} & = & \{ f \} \cup \callsofa{a} \\
        \callsofa{(\actlet{e}{x}{a})} & = & \callsofa{a} \\
        \callsofa{(\actifelse{e}{a_t}{a_f}{x}{a})} & = & \callsofa{a_t} \cup \callsofa{a_f} \cup \callsof{a} \\
        \callsofa{(\actassert{e}{a})} & = & \callsofa{a} \\
        \callsofa{(\actret{e})} & = & \emptyset \\
      \end{array}
    \end{math}
  \end{center}
\end{definition}

\section{Well-formedness of Modules}
\label{sec-wf}

In this section, we present a number of well-formedness conditions of
modules. Well-formedness for a programming language usually means a
set of conditions which can be \emph{statically checked} with a given
program. Since the conditions are static, they are usually defined
independent to the semantics definition, which has a dynamic aspect.
For instance, as briefly discussed in \refsect{sec-semmod}, it is not
allowed within an action to write the same register twice, or to call
the same method twice. These conditions can be statically determined
by iterating the action.

Whereas, a number of conditions cannot be statically checked, thus
should be defined in part of semantics. For instance, when combining
two substeps, two corresponding updated states and labels are required
to be disjoint, defined in the \Substeps{} semantics. However, in some
cases, it is too challenging to statically ensure the updated states
and the labels are disjoint.

\begin{figure}[h]
  \centering{
    \begin{subfigure}[b]{0.5\textwidth}
      \bsvmodnoreg{m}{
        \bsvnone{\pgmmeth}{f}{(p)}{
          \pgmif{} p \\
          \pgmthen{} \pgmwrite{r_1}{1}
          \pgmelse{} \pgmwrite{r_2}{2}
        }\\
        \bsvnone{\pgmmeth}{g}{(q)}{
          \pgmif{} q \\
          \pgmthen{} \pgmwrite{r_1}{1}
          \pgmelse{} \pgmwrite{r_2}{2}
        }
      }
    \end{subfigure}
  }
  \caption{Two methods always forming disjoint state updates}
  \label{ex-two-methods-disjoint}
\end{figure}

\reffig{ex-two-methods-disjoint} shows the case where two methods $f$
and $g$ yield disjoint state updates when $q = \neg p$, so they can be
concurrently executed. When a condition expression $p$ is \btrue{},
then $f$ writes $r_1$ and $g$ writes $r_2$. Otherwise, if $p$ is
\bfalse{}, then $q$ is \btrue{} so $f$ writes $r_2$ and $g$ writes
$r_1$. However, it is challenging to provide whether two predicates
($p$ and $q$ in the example) are disjoint or not. How can we collect
possible pairs of $(p, q)$ if $m$ is too complicated to figure out
callers of $f$ and $g$?

Now we define two well-formedness conditions of modules. All the
conditions are used to describe necessary conditions for a correct
module. By the correctness of a module, it means the module can be
synthesized into a hardware component which operates without errors,
and behaves like the module definition. The conditions are also
related to implications among semantics, which is one of main topics
of the thesis (See \refsect{TODO} for details). The two conditions are
as follows:
\begin{itemize}
  \item $(\wfdouble{m})$ ensures that there are no double writes or
    double calls \emph{for each action} in a module $m$.
  \item $(\wfcycle{m})$ ensures that there are no call cycles in a
    module $m$.
\end{itemize}

\paragraph{Well-formedness for avoiding double writes and calls}

Even if detecting double writes or calls is hard within a module, we
can provide a \emph{sound} static checker for an action. A sound
checker implies that if it says ``no double writes or calls'', then it
is correct. However, it might say ``there exist double writes or
calls'' even if such double writes or calls cannot happen.

\begin{figure}[h]
  \centering{
    \begin{subfigure}[b]{0.5\textwidth}
      \bsvmodnoreg{m}{
        \bsvnone{\pgmmeth}{f}{(p)}{
          \pgmif{} p\ \pgmthen{} \pgmwrite{r_1}{1}
          \pgmwrite{r_1}{1}
        }
      }
    \end{subfigure}
  }
  \caption{A method where double writes happen in some cases}
  \label{ex-maybe-double-writes}
\end{figure}

\reffig{ex-maybe-double-writes} shows the case where double writes
happen in some cases, but not in the other cases. If $p$ is \btrue{},
then double writes happen. Otherwise, double writes do not
happen. However, as explained with the case in
\reffig{ex-two-methods-disjoint}, analyzing predicates is difficult in
most cases. Thus, we should define a checker in a sound manner, by
assuming that $p$ is always \btrue{}.

Now we define a static checker for ensuring that there are no double
writes or calls in an action. (\wfdoubleap{a}) is inductively defined
as follows:

\begin{definition}
  \label{def-wfdoublea}
  \mbox{}
  \begin{center}
    \begin{math}
      \begin{array}{lcl}
        \wfdoublea{a} & = & \wfdoubleap{a}{\emptyset}{\emptyset} \textrm{, where} \\
        \wfdoubleap{(\actwrite{r}{e}{a})}{rs}{cs} & = & \wordif{} r \in rs \\
        & & \wordthen{} \bfalse{} \\
        & & \wordelse{} \wfdoubleap{a}{(r:rs)}{cs} \\
        \wfdoubleap{(\actcall{x}{f}{e}{a})}{rs}{cs} & = & \wordif{} f \in cs \\
        & & \wordthen{} \bfalse{} \\
        & & \wordelse{} \wfdoubleap{a}{rs}{(f:cs)} \\
        \wfdoubleap{(\actlet{e}{x}{a})}{rs}{cs} & = & \wfdoubleap{a}{rs}{cs} \\
        \wfdoubleap{(\actifelse{e}{a_t}{a_f}{x}{a})} & =
        & (\wfdoubleap{\concataction{a_t}{a}}{rs}{cs})\ \band{} \\
        & & (\wfdoubleap{\concataction{a_f}{a}}{rs}{cs}) \\
        \wfdoubleap{(\actassert{e}{a})}{rs}{cs} & = & \wfdoubleap{a}{rs}{cs} \\
        \wfdoubleap{(\actret{e})}{rs}{cs} & = & \btrue{} \\
      \end{array}
    \end{math}
  \end{center}
\end{definition}

(\wfdoublea{a}) is defined using (\wfdoubleap{a}{rs}{cs}), where $rs$
and $cs$ are registers and method calls collected while iterating an
action, respectively. TODO: more explanation.

The definition of (\wfdoublea{a}) is naturally extended to
(\wfdouble{m}), by applying it for each action in $m$.

\begin{definition}
  \label{def-wfdouble}
  \mbox{}
  \begin{center}
    \begin{math}
      \begin{array}{lcl}
        \wfdouble{(\modbasic{\regpair{r}{c}}{\rulepair{s}{a_s}}{\methodpair{f}{\lambda x.a_f}})} & =
        & (\wordforeach{} a_s.\; \wfdoublea{a_s} = \btrue)\ \band{} \\
        & & (\wordforeach{} a_f.\; \wfdouble{a_f} = \btrue) \\
        \wfdouble{(\modcomp{m_1}{m_2})} & = & (\wfdouble{m_1})\ \band{}\ (\wfdouble{m_2}) \\
      \end{array}
    \end{math}
  \end{center}
\end{definition}

\paragraph{Well-formedness for avoiding cycles} Ipsum.

\section{Inlining Semantics}

\subsection{Motivation}

\subsection{Defining Inlining Function}

\paragraph{Concatenating two actions}
In order to implement an inlining function, we first have to implement
a function which simply connects two actions. An operator
$(\concatsymb)$ concatenates two actions, inductively defined as
follows:

\begin{definition}
  \label{def-concataction}
  \mbox{}
  \begin{center}
    \begin{math}
      \begin{array}{rcl}
        \concataction{(\actwrite{r}{e}{a})}{a_c} & \triangleq & \actwrite{r}{e}{(\concataction{a}{a_c})} \\
        \concataction{(\actcall{x}{f}{e}{a})}{a_c} & \triangleq & \actcall{x}{f}{e}{(\concataction{a}{a_c})} \\
        \concataction{(\actlet{e}{x}{a})}{a_c} & \triangleq & \actlet{e}{x}{(\concataction{a}{a_c})} \\
        \concataction{(\actifelse{e}{a_t}{a_f}{x}{a})}{a_c} & \triangleq &
        \actifelse{e}{a_t}{a_f}{x}{(\concataction{a}{a_c})} \\
        \concataction{(\actassert{e}{a})}{a_c} & \triangleq & \actassert{e}{(\concataction{a}{a_c})} \\
        \concataction{(\actret{e})}{a_c} & \triangleq & \actlet{e}{x}{a_c} \\
      \end{array}
    \end{math}
  \end{center}
\end{definition}

The only nontrivial definition comes from the return statement
\actret{e}. Concatenating two actions involves to pass the return
value of the left action as an argument of the right action. However,
dynamic evaluation of an expression cannot be involved with the static
concatenation. The problem can be solved by using \wordlet{} syntax
structure, saying that we declare a name in which $e$ is bound, and
the value is used in the body ($\lambda x.a_c$). Considering the
semantics for \wordlet{}, it is natural to define concatenation in
such a way.

\paragraph{Inlining a method}
There are several ways to implement an inlining. One way is to define
it like a breadth-first search; during the iteration of a target
action, called methods are inlined for each method call. This inlining
process is applied repeatedly until there are no internal method
calls.

We define an inlining function in a somewhat different way. First, we
pick a function which will be inlined. Then for every action in a
target module, we search for all method calls to the target function,
and inline all of them. This process is applied for every defined
method in the module. The reason we chose this way is that inlining a
single method is closely related to semantic labels. See
\refsect{TODO} for the detailed reason why this inlining is easier to
prove properties.

For a target action $a$ and an inlining method $dm$, we define a
method-inlining operator for an action, denoted as $(\inlinedmsymb)$.

\begin{definition}
  \label{def-inlinedm}
  \mbox{}
  \begin{center}
    \begin{math}
      \begin{array}{rcl}
        \inlinedm{(\actwrite{r}{e}{a})}{dm} & \triangleq &
        \actwrite{r}{e}{(\inlinedm{a}{dm})} \\
        \inlinedm{(\actcall{x}{f}{e}{a})}{(f_i, \lambda x.a_f)} & \triangleq &
        \pgmif{} f = f_i \\
        & & \pgmthen{} \concataction{(\actlet{e}{y}{(\lambda x.a_f)\ y})}{(\inlinedm{a}{(f_i, \lambda x.a_f)})} \\
        & & \pgmelse{} \actcall{x}{f}{e}{(\inlinedm{a}{(f_i, \lambda x.a_f)})} \\
        \inlinedm{(\actlet{e}{x}{a})}{dm} & \triangleq &
        \actlet{e}{x}{(\inlinedm{a}{dm})} \\
        \inlinedm{(\actifelse{e}{a_t}{a_f}{x}{a})}{dm} & \triangleq &
        \actifelse{e}{(\inlinedm{a_t}{dm})}{(\inlinedm{a_f}{dm})}{x}{(\inlinedm{a}{dm})} \\
        \inlinedm{(\actassert{e}{a})}{dm} & \triangleq &
        \actassert{e}{(\inlinedm{a}{dm})} \\
        \inlinedm{(\actret{e})}{dm} & \triangleq & \actret{e} \\
      \end{array}
    \end{math}
  \end{center}
\end{definition}

A method-inlining operator for a module is naturally defined by
extending the operator for an action. For a target module $m$ and an
inlining \emph{method name} $f$, a method-inlining operator for a
module, denoted as $(\inlinedmmsymb)$, is defined as follows:

\begin{definition}
  \label{def-inlinedmm}
  \mbox{}
  \begin{center}
    \begin{math}
      \begin{array}{rcl}
        \inlinedmm{m}{f} & \triangleq & \pgmlet{} dm = (\methsofm{m})[f]\ \pgmin{} \\
        & & \pgmif{} \isrec{dm}\ \pgmthen{} \fail{} \\
        & & \pgmelse{} \\
        & & \pgmlet{} \listof{\regpair{r}{c}} = \regsofm{m}\ \pgmin{} \\
        & & \pgmlet{} \listof{\rulepair{s}{a_s}} = \rulesofm{m}\ \pgmin{} \\
        & & \pgmlet{} \listof{\methodpair{f}{\lambda x.a_f}} = \methsofm{m}\ \pgmin{} \\
        & & \modbasic{\regpair{r}{c}}
                  {\rulepair{s}{(\inlinedm{a}{dm})}}
                  {\methodpair{f}{\lambda x.(\inlinedm{a}{dm})}} \\
      \end{array}
    \end{math}
  \end{center}
\end{definition}

\paragraph{Inlining all defined methods}

Using the method-inlining operator $(\inlinedmsymb)$, now it is
straightforward to define an inlining function for a module. We simply
apply $(\inlinedmsymb)$ for all defined methods in the module.

However, inlining gets complicated when there is \emph{a call cycle}
in the module. \reffig{ex-inlining-callcycle} shows the case where
inlining for such module is problematic. A module $m$ has two methods
$f$ and $g$. It has a call cycle since $f$ calls $g$ and $g$ calls
$f$. When inlining $g$ first, $f$ eventually has a
\emph{self-recursive} call (a right figure). In this case, inlining
for $f$ cannot be progressed, since inlining itself will cause
register double-writes by $r_1$ and $r_2$. In order to avoid such
cases, the method-inlining operator checks whether the method which
will be inlined has a self-recursive method call or not. As described
in \refdef{def-inlinedmm}, (\isrec{dm}) ensures that $dm$ is not
self-recursive.

\begin{figure}[t]
  \begin{subfigure}[b]{0.5\textwidth}
    \bsvmodnoreg{m}{
      \bsvnone{\pgmmeth}{f}{}{
        \pgmwrite{r_1}{1}
        \pgmcalln{g}{}
      }\\
      \bsvnone{\pgmmeth}{g}{}{
        \pgmwrite{r_2}{2}
        \pgmcalln{f}{}
      }
    }
    \subcaption{Before inlining $g$}
  \end{subfigure}
  \begin{subfigure}[b]{0.5\textwidth}
    \bsvmodnoreg{m}{
      \bsvnone{\pgmmeth}{f}{}{
        \pgmwrite{r_1}{1}
        \pgmwrite{r_2}{2}
        \pgmcalln{f}{}
      }
    }
    \subcaption{After inlining $g$}
  \end{subfigure}
  \caption{A call cycle during inlining}
  \label{ex-inlining-callcycle}
\end{figure}

Now we naturally extend the method-inlining operator to a
methods-inlining operator $(\inlinedmssymb)$.
\begin{definition}
  \label{def-inlinedms}
  \mbox{}
  \begin{center}
    \begin{math}
      \begin{array}{rcl}
        \inlinedms{m}{\emptymap} & \triangleq & m \\
        \inlinedms{m}{f : fs} & \triangleq & \inlinedms{(\inlinedmm{m}{f})}{fs} \\
      \end{array}
    \end{math}
  \end{center}
\end{definition}
Using the methods-inlining operator $(\inlinedmssymb)$, we finally define the
inlining operator $\inline{\cdot}$ for a target module $m$.
\begin{definition}
  \label{def-inline}
  \mbox{}
  \begin{center}
    \begin{math}
      \inline{m} \triangleq \inlinedms{m}{(\namesof{(\methsofm{m})})}
    \end{math}
  \end{center}
\end{definition}

Why are method names used for inlining, instead of actual method
bodies? The reason is when we do inlining once for a particular
method, then all related other method bodies are changed. In other
words, when a method-inlining is done, we should take a new method
which will be inlined next, by taking it from the \emph{inlined
  module}, not from the original one.

\paragraph{Hiding internal methods}

The last step for inlining is to hide internal methods so that they
cannot be called from external modules. It is to ensure an original
module and the inlined one have the same behaviors. According to the
semantics, all methods which are internally called cannot be called by
external methods anymore. In terms of inlining, when all internal
calls are inlined, then the module should not have interfaces for
these inlined methods.

How do we know which defined methods should be hidden? The way to hide
such methods is simple; we just filter defined methods by checking
whether the target method is internally called by some rules or
methods. The complete inlining operator $\inlineF{\cdot}$ is defined
as follow:

\begin{definition}
  \label{def-inlineF}
  \mbox{}
  \begin{center}
    \begin{math}
      \inlineF{m} \triangleq
      (\regsofm{\inline{m}},
      \rulesofm{\inline{m}},
      \mapfilt{(\methsofm{\inline{m}})}{(\callsofm{m})}),
    \end{math}
  \end{center}
\end{definition}
where the map filtering operator $(\mapfilt{m}{l})$ filters out
elements of $m$ where the key is not in $l$.

\subsection{Inlining semantics}

\begin{figure}[t]
  \begin{subfigure}[b]{0.5\textwidth}
    \bsvmodnoreg{m}{
      \bsvnone{\pgmrule}{s}{}{
        \pgmwrite{r_1}{1}
        \pgmcalln{f}{}
      }\\
      \bsvnone{\pgmmeth}{f}{}{
        \pgmwrite{r_2}{2}
        \pgmcalln{g}{}
      }\\
      \bsvnone{\pgmmeth}{g}{}{
        \pgmwrite{r_3}{3}
      }
    }
    \subcaption{Before applying the inlining operator $\inlineF{\cdot}$}
  \end{subfigure}
  \begin{subfigure}[b]{0.5\textwidth}
    \bsvmodnoreg{\inlineF{m}}{
      \bsvnone{\pgmrule}{r}{}{
        \pgmwrite{r_1}{1}
        \pgmwrite{r_2}{2}
        \pgmwrite{r_3}{3}
      }
    }
    \subcaption{After applying the inlining}
  \end{subfigure}
  \caption{Inlining efficiency with respect to the \Step{} semantics}
  \label{ex-inlining-efficiency}
\end{figure}

Inlining semantics borrow the \Step{} semantics from the modular
semantics. The \StepInl{} semantics have a form of a judgment relation
(\semstepin{m}{o}{u}{l}), arguments have the same meaning as in
\Step{}.

\begin{definition}
  \label{def-semstepin}
  The judgment \semstepin{m}{o}{u}{l} is defined as follows:
  \begin{center}
    \begin{math}
      \begin{array}{c}
        \inference[StepInlIntro:]{\semstep{\inlineF{m}}{o}{u}{l}}
                  {\semstepin{m}{o}{u}{l}} \\
        \mbox{} \\
      \end{array}
    \end{math}
  \end{center}
\end{definition}

\Step{} semantics can be efficiently handled by using inlining. In
other words, dealing with \Step{} with inlined modules is easier than
with ordinary modules. \reffig{ex-inlining-efficiency} describes two
modules, where the left module is an original module (which is not
inlined), while the right one is inlined.

TODO: explain more.

\section{Big-step Semantics}

\subsection{Motivation}

\subsection{Definition of the Semantics}

\paragraph{Actions}

The only difference between the modular semantics and the big-step one
for Actions is how method calls are handled. In the modular semantics,
all method calls are collected regardless of the fact that the calls
are internal or not. In contrast, external calls are collected in the
big-step semantics, while internal calls are \emph{executed} by
looking at their actual bodies.

The semantics for actions have a form of a judgment relation
\sembigact{m}{o}{a}{u}{cs}{v}, where the arguments are similar to the
modular semantics. $m$ is the target module, $o : \sttype{}$ is the
old state, $a$ is the target action, $u : \sttype{}$ is the updated
state $a$, $cs : \lbtype{}$ is the called methods, and $v$ is the
return value.

\begin{definition}
  \label{def-sembigact}
  The judgment \sembigact{m}{o}{a}{u}{cs}{v} is defined as follows:
  \begin{center}
    \begin{math}
      \begin{array}{c}
        \inference[ActionWriteRegBig:]{\sembigact{m}{o}{a}{u}{cs}{v}
          & \semexpr{e}{o} = v_r} %% & r \notin u}
                  {\sembigact{m}{o}{\actwrite{r}{e}{a}}{\stupd{u}{r}{v_r}}{cs}{v}} \\
        \mbox{} \\
        \inference[ActionCallExtBig:]{\sembigact{m}{o}{(\lambda x.a)\ v_r}{u}{cs}{v}
          & \semexpr{e}{o} = v_a \\
          f \notin (\namesof{(\methsofm{m})})}
          %% & f \notin cs}
                  {\sembigact{m}{o}{\actcall{x}{f}{e}{a}}{u}{\lblupd{cs}{f}{(v_a, v_r)}}{v}} \\
        \mbox{} \\
        \inference[ActionCallIntBig:]{\sembigact{m}{o}{(\lambda x.a)\ v_r}{u}{cs}{v}
          & \semexpr{e}{o} = v_a \\
          (f, \lambda x.a_f) \in (\methsofm{m}) \\
          \sembigact{m}{o}{(\lambda x.a_f)\ v_a}{u_f}{cs_f}{v_r}
          & \sdisj{u}{u_f}
          & \ldisj{cs}{cs_f}
        }
                  {\sembigact{m}{o}{\actcall{x}{f}{e}{a}}{\splus{u}{u_f}}{\lplus{cs}{cs_f}}{v}} \\
        \mbox{} \\
        \inference[ActionLetBig:]{\sembigact{m}{o}{(\lambda x.a)\ v_l}{u}{cs}{v} & \semexpr{e}{o} = v_l}
                  {\sembigact{m}{o}{\actlet{e}{x}{a}}{u}{cs}{v}} \\
        \mbox{} \\
        \inference[ActionIfElseTBig:]{\sembigact{m}{o}{a_t}{u_t}{cs_t}{v_t} &
          \sembigact{m}{o}{(\lambda x.a)\ v_t}{u}{cs}{v} \\
          \semexpr{e}{o} = \btrue{}}
                  {\sembigact{m}{o}{\actifelse{e}{a_t}{a_f}{x}{a}}{\splus{u_t}{u}}{\splus{cs_t}{cs}}{v}} \\
        \mbox{} \\
        \inference[ActionIfElseFBig:]{\sembigact{m}{o}{a_f}{u_f}{cs_f}{v_f} &
          \sembigact{m}{o}{(\lambda x.a)\ v_f}{u}{cs}{v} \\
          \semexpr{e}{o} = \bfalse{}}
                  {\sembigact{m}{o}{\actifelse{e}{a_t}{a_f}{x}{a}}{\splus{u_f}{u}}{\splus{cs_f}{cs}}{v}} \\
        \mbox{} \\
        \inference[ActionAssertBig:]{\sembigact{m}{o}{a}{u}{cs}{v} & \semexpr{e}{o} = \btrue{}}
                  {\sembigact{m}{o}{\actassert{e}{a}}{u}{cs}{v}} \\
        \mbox{} \\
        \inference[ActionReturnBig:]{\semexpr{e}{o} = v}
                  {\sembigact{m}{o}{\actret{e}}{\emptymap{}}{\emptymap{}}{v}} \\
        \mbox{} \\
      \end{array}
    \end{math}
  \end{center}
\end{definition}

According to the semantics, only external calls are collected by $cs$
during an action execution. Inference rules are separated for internal
calls and external ones. ActionCallExtBig describes the case of
external calls. A target method $f$ should be guaranteed to be an
external call, by showing $f \notin (\namesof{(\methsofm{m})})$.
Whereas, in ActionCallIntBig, $f$ should be guaranteed to be an
internal call, by showing $(f, \lambda x.a_f) \in
(\methsofm{m})$. When we know the execution result of $(\lambda
x.a_f)\ v_a)$, where $v_a$ is the evaluated argument, we can describe
the final semantics for the internal call. The semantics are defined
in a big-step manner, since it requires the execution result by an
internal call.

%% Note that double writes ($r \notin u$ in ActionWriteRegBig) and calls
%% ($f \notin cs$ in ActionCallExtBig) are checked in the semantics,
%% which was a part of well-formedness conditions in the modular
%% semantics. These conditions are added to prove that 

\paragraph{BigSubstep}

The big-step semantics also have a notion similar to \Substep{} in the
modular semantics, called \Bigsubstep{}. The concept is similar to
\Substep{}; it simply lifts the semantics for Actions to one for a
single rule or a method. However, \Bigsubstep{} continues to execute
internal calls by looking at method bodies. Thus, resulting labels
from \Bigsubstep{} does not contain internal calls.

The \Bigsubstep{} semantics have a form of a judgment relation
\sembigss{m}{o}{u}{\alpha}{ds}{cs}, where arguments are similarly
defined as in \Substep{}. $m$ is the target module, $o$ is the old
state, $u$ is the updated state, and \semlbl{\alpha}{ds}{cs} is the
label formed by the execution.

\begin{definition}
  \label{def-sembigss}
  The judgment \sembigss{m}{o}{u}{\alpha}{ds}{cs} is defined as follows:
  \begin{center}
    \begin{math}
      \begin{array}{c}
        \inference[EmptyRuleBig:]{}
                  {\sembigss{m}{o}{\emptymap}
                    {\alpharule{\epsilon}}{\emptymap}{\emptymap}} \\
        \mbox{} \\
        \inference[EmptyMethBig:]{}
                  {\sembigss{m}{o}{\emptymap}
                    {\alphameth}{\emptymap}{\emptymap}} \\
        \mbox{} \\
        \inference[SingleRuleBig:]{\rulepair{s}{a} \in \rulesofm{m} & \sembigact{m}{o}{a}{u}{cs}{v}}
                  {\sembigss{m}{o}{u}{\alpharule{s}}{\emptymap}{cs}} \\
        \mbox{} \\
        \inference[SingleMethBig:]{\methodpair{f}{\lambda x.a} \in \methsofm{m} &
          \sembigact{m}{o}{(\lambda x.a)\ v_a}{u}{cs}{v_r}}
                  {\sembigss{m}{o}{u}{\alphameth{}}{\lblupd{}{f}{(v_a, v_r)}}{cs}} \\
        \mbox{} \\
      \end{array}
    \end{math}
  \end{center}
\end{definition}

\paragraph{BigStep}

Unlike the modular semantics, the big-step semantics does not need to
apply the \hidesym{} operator at the end of the semantics. This is
because labels from \Bigsubstep{} does not contain any internal
calls. Hence, we directly define the final \Bigstep{} semantics using
\Bigsubstep{}, skipping the notion of \Substeps{} in the modular
semantics.

The \Bigstep{} semantics are defined as a judgment relation
(\sembigstep{m}{o}{u}{l}), arguments have the same meaning as in
\Bigsubstep{}.

\begin{definition}
  \label{def-sembigstep}
  The judgment \sembigstep{m}{o}{u}{l} is defined as follows:
  \begin{center}
    \begin{math}
      \begin{array}{c}
        \inference[StepNilBig:]{}
                  {\sembigstep{m}{o}{\emptymap}{\semlbl{\alphameth}{\emptymap}{\emptymap}}} \\
        \mbox{} \\
        \inference[StepConsBig:]{\sembigstep{m}{o}{u_1}{l_1} & \sembigssr{m}{o}{u_2}{l_2}
          & \sdisj{u_1}{u_2} & \ldisj{l_1}{l_2}}
                  {\sembigstep{m}{o}{\splus{u_1}{u_2}}{\lplus{l_1}{l_2}}} \\
        \mbox{} \\
      \end{array}
    \end{math}
  \end{center}
\end{definition}

