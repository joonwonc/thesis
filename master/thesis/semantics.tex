\chapter{Various Semantics for Hardware Systems}

\section{Syntax}

\paragraph{Expressions}
We begin by defining syntax for expressions. Expressions
consist of constant, register read, variable, and an inductive
operation among expressions.

\begin{definition}
  \label{def-expression}
  An expression $e$ is inductively defined as follows:
  \begin{center}
    \begin{math}
      \begin{array}{rcll}
        \textrm{Expression}\quad e & ::= & c & \textrm{(constant)} \\
        & | & r & \textrm{(register read)} \\
        & | & x & \textrm{(variable)} \\
        & | & \eop{e} & \textrm{(operation)} \\
      \end{array}
    \end{math}
  \end{center}
\end{definition}

Constants denotes all concrete values in hardware design. A number of
constants with different bit-widths may exist in real hardware design,
but they are abstracted into a single type. Let \setconst{} be the set
of such constants. $c \in \setconst{}$ will be used as a typical
charater representing a constant throughout the thesis.

$r \in \setregs{}$ in expression represents the value of a register
$r$, where \setregs{} is the set of register names. $x$ denotes a
variable bound by a continuation. We define syntax as a
continuation-passing style (CPS), hence the variable is used to get
the value of a continuation argument. Lastly, \eop{e} abstracts all
inductive operations among expressions. Notation $\vec{\cdot}\ $ is
used to denote the list of objects.

\paragraph{Actions}
As explained in \refsect{TODO}, an action is a unit for describing
hardware behaviors, which should ensure atomicity. Actions consist of
a write to a register, a method call, an assert, and a return.

\begin{definition}
  \label{def-action}
  An action $a$ is inductively defined as follows:
  \begin{center}
    \begin{math}
      \begin{array}{rcll}
        \textrm{Action}\quad a & ::= & \actwrite{r}{e}{a} & \textrm{(register write)} \\
        & | & \actcall{x}{f}{e}{a} & \textrm{(method call)} \\
        & | & \actassert{e}{a} & \textrm{(assert)} \\
        & | & \actret{e} & \textrm{(return)} \\
      \end{array}
    \end{math}
  \end{center}
\end{definition}

A register write action takes a register name $r$ and an expression
$e$ to assign the evaluation of $e$ to $r$. A method call action takes
a method name $f \in \setmeths{}$ to call, an expression $e$ as an
argument. A return value for the call is bound to a variable $x$ in a
lambda continuation. \setmeths{} denotes the set of method names. An
assert action takes an expression $e$ to be checked to progress the
continuation. Lastly, A return action takes $e$ as a return
value. Note that all action components except a return action also
takes an action $a$ as a continuation.

\paragraph{Modules}
A module is a unit of hardware component which has its own state (a
set of registers), introduces internal state change fired by actions,
and creates method calls to communicate with other modules. A module
syntactically consists of registers, rules, and methods.

\begin{definition}
  \label{def-module}
  A module $m$ is inductively defined as follows:
  \begin{center}
    \begin{math}
      \begin{array}{rcll}
        \textrm{Module}\quad m & ::=
        & \modbasic{\regpair{r}{c}}{\rulepair{s}{a}}{\methodpair{f}{\lambda x.a}}
        & \textrm{(basic module)} \\
        & | & \modcomp{m}{m} & \textrm{(composed module)}
      \end{array}
    \end{math}
  \end{center}
\end{definition}

Modules is either a \emph{basic module} or a \emph{composed module}
where two modules are composed inductively. In a basic module,
registers has a form of $\listof{\regpair{r}{c}}$, where $c$ is the
default value for a corresponding register $r$. Rules are defined as
$\listof{\rulepair{s}{a}}$, where $s$ is the name of a rule and $a$ is
the body of it. Methods are defined as $\listof{\methodpair{f}{\lambda
    x.a}}$, where $f$ is the name of a method and $\lambda x.a$ is the
body of it. $x$ in the lambda form serves to take an argument of the
method.

Note that all names for registers, rules, and methods are assumed to
be globally unique in the module. A simple static checker can be
implemented to confirm there are no name conflicts inside a module.

\section{Modular Semantics}

In this section, we present modular semantics for hardware design. A
version of modular semantics has been defined in \cite{murali-thesis}.
However, this section defines a slightly different version of it, in
which the current \Kami{} framework uses. The motivation is kept
unchanged: semantics are defined with respect to the module
definition, which includes the one for combining modules. The
semantics defined in this section will be used throughout the thesis,
including the consistency proofs in \refsect{TODO}. Specifically, the
semantics for expressions and actions are completely borrowed from
\cite{murali-thesis}. Other higher semantics differ.

\paragraph{Expressions}

We start defining semantics from the one for expressions.
\refdef{def-semexpr} describes denotational semantics \ssemexpr{\cdot}
for expressions.

\begin{definition}
  \label{def-semexpr}
  $\ssemexpr{\cdot} : (\sttype{}) \to \setconst$ is
  defined as follows:
  \begin{center}
    \begin{math}
      \begin{array}{rcl}
        \semexpr{c}{o} & = & c \\
        \semexpr{r}{o} & = & o(r) \\
        \semexpr{x}{o} & = & \textsf{undefined} \\
        \semexpr{\eop{e}}{o} & = & \denot{\seop{}}(\listof{\semexpr{e}{o}}) \\
      \end{array}
    \end{math}
  \end{center}
\end{definition}

The semantics for constant and register read are straightforward. The
constant itself is returned for a constant. Register read is performed
by reading its value from the \emph{old state} $o: \sttype$.

The semantics for variable is not defined, since it should be
substituted to the value by $\beta$-reduction in higher
semantics. Technically, in the \Kami{} framework, syntax is defined by
PHOAS~\cite{adam-icfp}, thus the variable term is abstracted into a
syntax constructor $\textsf{Var}$. In this case, we rather can define
$\semexpr{\textsf{Var}\ v}{o} = v$, where $v$ is already substituted
to a value but still contained in the constructor.

Lastly, the semantics for operation is defined by using the semantic
definition for \seop{}, denoted as $\denot{\seop{}}$. Arguments are
inductively evaluated by the same semantics function.

\paragraph{Actions}

Action is the basic unit where the communication among modules are
triggered by method calls. As defined in \refdef{def-action}, actions
contain a method call. A method call can be either internal (calling a
method in the module), or external (calling a method not in the
module).

In the modular semantics, all method calls are treated
nondeterministically. In other words, the semantics for method calls,
on the level of action, are defined as if we know the return value of
the method for every argument. The validity of such assumptions are
checked on higher-level semantics.

The semantics for actions have a form of a judgment relation
\semact{o}{a}{u}{cs}{v}, where $o : \sttype{}$ is the old state, $a$
is the target action, $u : \sttype{}$ is the \emph{updated state}
after executing $a$, $cs : \lbtype{}$ is the map from method names to
pairs of argument and return values. Lastly, $v$ is the return value
of $a$.

\begin{definition}
  \label{def-semaction}
  The judgment \semact{o}{a}{u}{cs}{v} is defined as follows:
  \begin{center}
    \begin{math}
      \begin{array}{c}
        \inference[ActionWriteReg:]{\semact{o}{a}{u}{cs}{v} & \semexpr{e}{o} = v_r}
                  {\semact{o}{\actwrite{r}{e}{a}}{\stupd{u}{r}{v_r}}{cs}{v}} \\
        \mbox{} \\
        \inference[ActionCall:]{\semact{o}{(\lambda x.a)\ v_r}{u}{cs}{v} & \semexpr{e}{o} = v_a}
                  {\semact{o}{\actcall{x}{f}{e}{a}}{u}{\lblupd{cs}{f}{(v_a, v_r)}}{v}} \\
        \mbox{} \\
        \inference[ActionAssert:]{\semact{o}{a}{u}{cs}{v} & \semexpr{e}{o} = \btrue{}}
                  {\semact{o}{\actassert{e}{a}}{u}{cs}{v}} \\
        \mbox{} \\
        \inference[ActionReturn:]{\semexpr{e}{o} = v}
                  {\semact{o}{\actret{e}}{\emptymap{}}{\emptymap{}}{v}} \\
      \end{array}
    \end{math}
  \end{center}
\end{definition}

Semantics for actions do not check double-writes of registers or
double-calls of method calls. For instance, in the rule
ActionWriteReg, an evaluated value is simply updated to the updated
state $u$ by the register name $r$, without confirming $u$ does not
have the value for $r$. Similarly, ActionCall does not check $cs$
already has the value for $f$. The reason is that these conditions can
be checked \emph{statically}; we call such conditions
\emph{well-formedness} of actions. Detailed static checks and
properties will be discussed in \refsect{TODO}.

An assert and a return action have straightforward semantics. Assert
requires its argument $e$ to be \btrue{}, in order to continue
execution. Return simply evaluates the expression $e$ to return the
value.

\paragraph{Substep}
Once the semantics for actions are defined, it should be applied to
describe the semantics of rule or method executions. As explained in
\refsect{TODO}, \Bluespec{} and \Kami{} follow the one-rule-at-a-time
semantics; only one rule is executed in a cycle, while multiple method
calls are executed. The \Substep{} semantics defines a single
execution by a rule or a method. It is simply a lift from the
semantics for actions, since a rule or a method is defined by an
action.

A label is firstly employed on this semantics, representing
communications with other external modules. A label has a form of
\semlbl{\alpha}{ds}{cs}. $\alpha$ contains the information whether the
label is formed by a rule or not. If the label is formed by a rule $s
\in \setrules$, it takes \alpharule{s}. Otherwise, it takes
\alphameth{}. $\alpha$ is used to ensure that the label follows the
one-rule-at-a-time semantics. $ds$ denotes \emph{defined methods},
indicating multiple methods executed in a cycle. Similarly, $cs$
denotes \emph{called methods}, indicating methods which are called in
a cycle.

The \Substep{} semantics have a form of a judgment relation
\semsstep{m}{o}{u}{\alpha}{ds}{cs}, where $m$ is the target module,
$o$ is the old state, $u$ is the updated state, and
\semlbl{\alpha}{ds}{cs} is the label formed in a cycle.

\begin{definition}
  \label{def-semsstep}
  The judgment \semsstep{m}{o}{u}{\alpha}{ds}{cs} is defined as follows:
  \begin{center}
    \begin{math}
      \begin{array}{c}
        \inference[EmptyRule:]{}
                  {\semsstep{m}{o}{\emptymap}
                    {\alpharule{\epsilon}}{\emptymap}{\emptymap}} \\
        \mbox{} \\
        \inference[EmptyMeth:]{}
                  {\semsstep{m}{o}{\emptymap}
                    {\alphameth}{\emptymap}{\emptymap}} \\
        \mbox{} \\
        \inference[SingleRule:]{\rulepair{s}{a} \in \rulesof{m} & \semact{o}{a}{u}{cs}{v}}
                  {\semsstep{m}{o}{u}{\alpharule{s}}{\emptymap}{cs}} \\
        \mbox{} \\
        \inference[SingleMeth:]{\methodpair{f}{\lambda x.a} \in \methsof{m} &
          \semact{o}{(\lambda x.a)\ v_a}{u}{cs}{v_r}}
                  {\semsstep{m}{o}{u}{\alphameth{}}{\lblupd{}{f}{(v_a, v_r)}}{cs}} \\
      \end{array}
    \end{math}
  \end{center}
\end{definition}

EmptyRule and EmptyMeth describe cases where no progress is made in a
cycle. These cases are similar to $\epsilon$-steps for describing
program behaviors, like the one in CompCert~\cite{TODO}. However, an
empty step by a rule and one by a method should be separately defined
in the \Substep{} semantics, in order to give explicit information
when defining the refinement relation. See \refsect{TODO} for details.

SingleRule and SingleMeth describe the case where a rule or a method
is executed in a cycle, respectively. In SingleRule, a rule $(s, a)$
should be defined in the module $m$. \rulesof{m} is a function which
collects all rules in the module, inductively defined as follow:
\begin{definition}
  \label{def-rulesof}
  \mbox{}
  \begin{center}
    \begin{math}
      \begin{array}{lcl}
        \rulesof{(\_, \listof{\rulepair{s}{a}}, \_)} & = & \listof{\rulepair{s}{a}}\\
        \rulesof{(\modcomp{m1}{m2})} & = & (\rulesof{m1}) \cup (\rulesof{m2})\\
      \end{array}
    \end{math}
  \end{center}
\end{definition}
Similarly, a method $(f, \lambda x.a)$ should be defined in $m$ in the
SingleMeth case. \methsof{m} is also similarly defined as follow:
\begin{definition}
  \label{def-methsof}
  \mbox{}
  \begin{center}
    \begin{math}
      \begin{array}{lcl}
        \methsof{(\_, \_, \listof{\methodpair{f}{\lambda x.a}})} & = & \listof{\methodpair{f}{\lambda x.a}} \\
        \methsof{(\modcomp{m1}{m2})} & = & (\methsof{m1}) \cup (\methsof{m2})\\
      \end{array}
    \end{math}
  \end{center}
\end{definition}
Once a rule or a method is found, proper labels are formed simply by
using information from the semantics of actions.

\paragraph{Substeps}
The \Substeps{} semantics collect multiple substeps which are
simultaneously executed in a cycle. There are a few conditions whether
substeps can be merged or not. Basically the updated states and labels
from \Substep{} are used. Firstly, two substeps with \alpharule{\cdot}
labels cannot be merge, since it breaks the one-rule-at-a-time
semantics. Two updated states should be disjoint unless it breaks the
double-write policy. Similarly, two defined methods and two called
methods should be disjoint not to break double-call.

The \Substeps{} semantics have a form of a judgment relation
\semsss{m}{o}{u}{l}, arguments mostly have the same meaning as in
\Substep{}. $l$ denotes the label formed in a cycle.

\begin{definition}
  \label{def-semsss}
  The judgment \semsss{m}{o}{u}{l} is defined as follows:
  \begin{center}
    \begin{math}
      \begin{array}{c}
        \inference[SubstepsNil:]{}
                  {\semsss{m}{o}{\emptymap}
                    {\semlbl{\alphameth}{\emptymap}{\emptymap}}} \\
        \mbox{} \\
        \inference[SubstepsCons:]{\semsss{m}{o}{u_1}{l_1} & \semsstepr{m}{o}{u_2}{l_2} & \sdisj{u_1}{u_2} & \ldisj{l_1}{l_2}}
                  {\semsss{m}{o}{\splus{u_1}{u_2}}{\lplus{l_1}{l_2}}} \\
        \mbox{} \\
      \end{array}
    \end{math}
  \end{center}
\end{definition}

In SubstepsCons, disjointnesses of states and labels are both denoted
by the operation \sdisj{}{}, while definitions differ. For states
$u_1$ and $u_2$, \sdisj{u_1}{u_2} defines the two finite state maps
are disjoint, which can be defined naturally:

\begin{center}
  \begin{math}
    \sdisj{u_1}{u_2} \triangleq \forall r. r \notin \domof{u_1} \vee r \notin \domof{u_2}
  \end{math}
\end{center}

For labels $l_1$ and $l_2$, \ldisj{l_1}{l_2} defines the two labels
are combinable:

\begin{definition}
  \label{def-ldisj}
  \mbox{}
  \begin{center}
    \begin{math}
      \begin{array}{rcl}
        \ldisj{l_1}{l_2} & \triangleq &
        \anndisj{(\annotof{l_1})}{(\annotof{l_2})} \wedge
        \mdisj{(\defsof{l_1})}{(\defsof{l_2})} \wedge
        \mdisj{(\callsof{l_1})}{(\callsof{l_2})} \textrm{, where} \\
        \anndisj{\alpha_1}{\alpha_2} & \triangleq &
        (\alpha_1 = \alphameth) \vee (\alpha_2 = \alphameth) \\
      \end{array}
    \end{math}
  \end{center}
\end{definition}

Once the disjointnesses are defined, we can use the disjoint union for
updated states \splus{u_1}{u_2} and the merged label \lplus{l_1}{l_2},
where the label merging is defined as follows:

\begin{definition}
  \label{def-lplus}
  \mbox{}
  \begin{center}
    \begin{math}
      \begin{array}{rcl}
        \lplus{l_1}{l_2} & \triangleq &
        \semlbl{\annplus{\annotof{l_1}}{\annotof{l_2}}}
               {\mplus{\defsof{l_1}}{\defsof{l_2}}}
               {\mplus{\callsof{l_1}}{\callsof{l_2}}} \textrm{, where} \\
        \annplus{\alpha_1}{\alpha_2} & \triangleq &
        \textsf{if}\ \alpha_1 = \alpharule{s}\ \textsf{then}\ \alpha_1\
        \textsf{else}\ \alpha_2 \\
      \end{array}
    \end{math}
  \end{center}
\end{definition}

The only nontrivial definition is \annplus{\alpha_1}{\alpha_2}, which
is to take the rule annotation from two annotations, \alphameth{} if
both of them are not a rule annotation. Note that the two annotations
cannot both be the rule annotation by the condition
\anndisj{\alpha_1}{\alpha_2}.

\paragraph{Step}



\section{Well-formedness of Modules}
\section{Inlining Semantics}
\section{Operational Semantics}

